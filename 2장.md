# 2장 코틀린 기초

**2장에서 다루는 내용**

- 함수, 변수, 클래스, enum, 프로퍼티를 선언하는 방법
- 제어 구조
- 스마트 캐스트
- 예외 던지기와 예외 잡기



## 2.1 기본 요소: 함수와 변수

### 2.1.1 Hello, World!

```kotlin
fun main(args: Array<String>) {
  println("Hello, world!")
}
```

- 함수를 선언할 때 fun 키워드를 사용한다.
- 파라미터 이름 뒤에 그 파라미터의 타입을 쓴다. 변수를 선언할 때도 마찬가지 방식으로 타입을 지정한다.
- 함수를 최상위 수준에 정의할 수 있다. 꼭 클래스 안에 함수를 넣어야 할 필요가 없다.
- 배열도 일반적인 클래스와 마찬가지다. 코틀린에는 자바와 달리 배열 처리를 위한 문법이 따로 존재하지 않는다.
- System.out.println 대신에 println이라고 쓴다. 코틀린 표준 라이브러리는 여러 가지 표준 자바 라이브러리 함수를 간결하게 사용할 수 있게 감싼 래퍼를 제공한다. println도 그런 함수 중 하나다.
- 최신 프로그래밍 언어 경향과 마찬가지로 줄 끝에 세미콜론(;)을 붙이지 않아도 좋다.



### 2.1.2 함수

```kotlin
fun max(a: Int, b: Int): Int {
  return if (a>b) a else b
}

println(max(1, 2))
```

함수 선언은 fun 키워드로 시작한다. fun 다음에는 함수 이름이 온다. 예제는 max라는 이름의 함수다. 함수 이름 뒤에는 괄호 안에 파라미터 목록이 온다. 함수의 반환 타입은 파라미터 목록의 닫는 괄호 다음에 오는데, 괄호의 반환 타입 사이를 콜론(:)으로 구분해야 한다.

코틀린 if는 값을 만들어내지 못하는 문장이 아니고 결과를 만드는 식이라는 점이 흥미롭다. 이 예제의 코틀린 if 식은 자바 3항 연산자로 작성한 (a>b)? a:b 식과 비슷하다.

**문(statement)과 식(expression)의 구분**

`코틀린에서 if는 식이지 문이 아니다. 식은 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여할 수 있는 반면 문은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어내지 않는다는 차이가 있다. 자바에서는 모든 제어 구조가 문인 반면 코틀린에서는 루프를 제외한 대부분의 제어 구조가 식이다. 나중에 이 책에서도 보여주겠지만, 제어 구조를 다른 식으로 엮어낼 수 있으면 여러 일반적인 패턴을 아주 간결하게 표현할 수 있다. 반면 대입문은 자바에서는 식이었으나 코틀린에서는 문이 됐다. 그로 인해 자바와 달리 대입식과 비교식을 잘못 바꿔 써서 버그가 생기는 경우가 없다.`

**식이 본문인 함수**

조금 전에 살펴본 함수를 더 간결하게 표현할 수도 있다.

```kotlin
fun max(a: Int, b: Int): Int = if (a>b) a else b
```

본문이 중괄호로 둘러싸인 함수를 **블록이 본문인 함수** 라 부르고, 등호와 식으로 이뤄진 함수를 **식이 본문인 함수** 라고 부른다.

코틀린에서는 식이 본문인 함수가 자주 쓰인다. 그런 함수의 본문 식에는 단순한 산술식이나 함수 호출 식뿐 아니라 if, when, try 등의 더 복잡한 식도 자주 쓰인다. 잠시 후에 when에 대해 설명할 때 그런 함수를 보여준다.

반환 타입을 생략하면 max 함수를 더 간략하게 만들 수 있다.

```kotlin
fun max(a: Int, b: Int) = if (a>b) a else b
```

**반환 타입을 생략할 수 있는 이유**

코틀린은 정적 타입 지정 언어이므로 컴파일 시점에 모든 식의 타입을 지정해야 한다. 실제로 모든 변수나 모든 식에는 타입이 있으며, 모든 함수는 반환 타입이 정해져야 한다. 하지만 식이 본문인 함수의 경우 굳이 사용자가 반환 타입을 적지 않아도 컴파일러가 함수 본문 식을 분석해서 식의 결과 타입을 함수 반환 타입으로 정해준다. 이렇게 컴파일러가 타입을 분석해 프로그래머 대신 프로그램 구성 요소의 타입을 정해주는 기능을 **타입 추론** 이라 부른다.

<u>식이 본문인 함수의 반환 타입만 생략 가능하다</u> 는 점에 유의하라. 블록이 본문인 함수가 값을 반환한다면 반드시 반환 타입을 지정하고 return문을 사용해 반환 값을 명시해야 한다.



### 2.1.3 변수

```kotlin
val question = "삶, 우주, 그리고 모든 것에 대한 궁극적인 질문"
val answer = 42	//Int
val answer: Int = 42
val yearsToCompute = 7.5e6	//Double
```

초기화 식을 사용하지 않고 변수를 선언하려면 변수 타입을 반드시 명시해야 한다.

```kotlin
val answer: Int
answer = 42
```

초기화 식이 없다면 변수에 저장될 값에 대해 아무 정보가 없기 때문에 컴파일러가 타입을 추론할 수 없다. 따라서 그런 경우 타입을 반드시 지정해야 한다.

**변경 가능한 변수와 변경 불가능한 변수**

변수 선언 시 사용하는 키워드

- **val** (값을 뜻하는 value에서 따옴): 변경 불가능한(immutable) 참조를 저장하는 변수다. val로 선언된 변수는 일단 초기화하고 나면 재대입이 불가능하다. 자바로 말하자면 final 변수에 해당한다.
- **var** (변수를 뜻하는 variable에서 따옴): 변경 가능한(mutable) 참조다. 이런 변수의 값은 바뀔 수 있다. 자바의 일반 변수에 해당한다.

**기본적으로 모든 변수를 val 키워드를 사용해 불변 변수로 선언하고, 나중에 꼭 필요할 때에만 var로 변경하라.**

val 변수는 블록을 실행할 때 정확히 한 번만 초기화돼야 한다. 하지만 어떤 블록이 실행될 때 오직 한 초기화 문장만 실행됨을 컴파일러가 확인할 수 있다면 조건에 따라 val 값을 다른 여러 값으로 초기화할 수도 있다.

``` kotlin
val message: String
if(canPerformOperation()) {
  message = "Success"
  // ...연산을 수행한다.
}
else {
  message = "Failed"
}
```

val 참조 자체는 불변일지라도 그 참조가 가리키는 객체의 내부 값을 변경될 수 있다는 사실을 기억하라.

```kotlin
val languages = arrayListOf("Java")	// 불변 참조를 선언한다.
languages.add("Kotlin")	// 참조가 가리키는 객체 내부를 변경한다.
```

var 키워드를 사용하면 변수의 값을 변경할 수 있지만 변수의 타입은 고정돼 바뀌지 않는다. 예를 들어 다음 코드는 컴파일 할 수 없다.

```kotlin
var answer = 42
answer = "no answer"	// Error: type mismatch 컴파일 오류 발생
```

컴파일러는 변수 선언 시점의 초기화 식으로부터 변수의 타입을 추론하며, 변수 선언 이후 변수 재대입이 이뤄질 때는 이미 추론한 변수의 타입을 염두에 두고 대입문의 타입을 검사한다.

어떤 타입의 변수에 다른 타입의 값을 저장하고 싶다면 **반환 함수** 를 써서 값을 변수의 타입으로 변환하거나, 값을 변수에 대입할 수 있는 타입으로 **강제 형 변환** 해야 한다.



### 2.1.4 더 쉽게 문자열 형식 지정: 문자열 템플릿

```kotlin
fun main(args: Array<String>) {
  val name = if (args.size > 0) args[0] else "Kotlin"
  println("Hello, $name!")
  /* "Bob"을 인자로 넘기면 "Hello, Bob!"을 출력하고
  		아무 인자도 없으면 "Hello, Kotlin!"을 출력한다. */
}
```

이 예제는 **문자열 템플릿** 이라는 기능을 보여준다. 이 코드는 name이라는 변수를 선언하고 그 다음 줄에 있는 문자열 리터럴 안에서 그 변수를 사용했다. 여러 스크립트 언어와 비슷하게 코틀린에서도 변수를 문자열 안에 사용할 수 있다. 문자열 리터럴의 필요한 곳에 변수를 넣되 변수 앞에 $를 추가해야 한다.

물론 컴파일러는 각 식을 정적으로 컴파일 시점에 검사하기 때문에 존재하지 않는 변수를 문자열 템플릿 안에서 사용하면 컴파일 오류가 발생한다.

\$ 문자를 문자열에 넣고 싶으면 println("\\$x")와 같이 \\를 사용해 \$를 이스케이프 시켜야 한다. println("\\\$x")는 화면에 x의 값을 출력하지 않고 \$x를 출력한다.

문자열 템플릿 안에 사용할 수 있는 대상은 간단한 변수 이름만으로 한정되지 않는다. 복잡한 식도 중괄호({})로 둘러싸서 문자열 템플릿 안에 넣을 수 있다.

```kotlin
fun main(args: Array<String>) {
  if (args.size > 0) {
    println("Hello, ${args[0]}!")	// args 배열의 첫 번째 원소를 넣기 위해 ${} 구문을 사용한다.
  }
}
```

`문자열 템플릿 안에서 변수 이름만 사용하는 경우라도 ${name}처럼 중괄호로 변수명을 감싸는 습관을 들이면 더 좋다. 필요할 때 정규식 등을 통해 검색하거나 일괄 변환할 때도 중괄호를 쓴 경우 처리가 더 쉽고, 코드를 사람이 읽을 때도 문자열 템플릿 안에서 변수가 쓰인 부분을 더 쉽게 식별할 수 있다.`

중괄호로 둘러싼 식 안에서 큰 따옴표를 사용할 수도 있다.

```kotlin
fun main(args: Array<String>) {
  println("Hello, ${if (args.size > 0) args[0] else "someone"}!")
}
```



## 2.2 클래스와 프로퍼티

### 2.2.1 프로퍼티



### 2.2.2 커스텀 접근자



### 2.2.3 코틀린 소스코드 구조: 디렉터리와 패키지



## 2.3 선택 표현과 처리: enum과 when

### 2.3.1 enum 클래스 정의



### 2.3.2 when으로 enum 클래스 다루기



### 2.3.3 when과 임의의 객체를 함께 사용



### 2.3.4 인자 없는 when 사용



### 2.3.5 스마트 캐스트: 타입 검사와 타입 캐스트를 조합



### 2.3.6 리팩토링: if를 when으로 변경



### 2.3.7 if와 when의 분기에서 블록 사용



## 2.4 대상을 이터레이션: while과 for 루프

### 2.4.1 while 루프

### 2.4.2 수에 대한 이터레이션: 범위와 수열

### 2.4.3 맵에 대한 이터레이션

### 2.4.4 in으로 컬렉션이나 범위의 원소 검사



## 2.5 코틀린의 예외 처리

### 2.5.1 try, catch, finally

### 2.5.2 try를 식으로 사용



## 2.6 요약

- 함수를 정의할 때 fun 키워드를 사용한다. val고 var는 각각 읽기 전용 변수와 변경 가능한 변수를 선언할 때 쓰인다.
- 문자열 템플릿을 사용하면 무자열을 연결하지 않아도 되므로 코드가 간결해진다. 변수 이름 앞에 \$를 붙이거나, 식을 \${식}처럼 ${}로 둘러싸면 변수나 식의 값을 문자열 안에 넣을 수 있다.
- 코틀린에서는 값 객체 클래스를 아주 간결하게 표현할 수 있다.
- 다른 언어에도 있는 if는 코틀린에서 식이며, 값을 만들어낸다.
- 코틀린 when은 자바의 switch와 비슷하지만 더 강력하다.
- 어떤 변수의 타입을 검사하고 나면 굳이 그 변수를 캐스팅하지 않아도 검사한 타입의 변수처럼 사용할 수 있다. 그런 경우 컴파일러가 스마트 캐스트를 활용해 자동으로 타입을 바꿔준다.
- for, while, do-while 루프는 자바가 제공하는 같은 키워드의 기능과 비슷하다. 하지만 코틀린의 for는 자바의 for보다 더 편리하다. 특히 맵을 이터레이션하거나 이터레이션하면서 컬렉션의 원소와 인덱스를 함께 사용해야 하는 경우 코틀린의 for가 더 편리하다.
- 1 . . 5와 같은 식의 범위를 만들어낸다. 범위와 수열은 코틀린에서 같은 문법을 사용하며, for 루프에 대해 같은 추상화를 제공한다. 어떤 값이 범위 안에 들어 있거나 들어있지 않은지 검사하기 위해서 in이나 ! in을 사용한다.
- 코틀린 예외 처리는 자바와 비슷하다. 다만 코틀린에서는 함수가 던질 수 있는 예외를 선언하지 않아도 된다.
